import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

// Precache all static assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Cache the API responses with network-first strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 1 day
      }),
    ],
  })
);

// Cache static assets with cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'style' || 
                   request.destination === 'script' || 
                   request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-resources',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Cache images with stale-while-revalidate strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new StaleWhileRevalidate({
    cacheName: 'image-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Handle offline fallback
const FALLBACK_HTML_URL = '/offline.html';
self.addEventListener('install', (event) => {
  const cacheOfflineFallbackPage = async () => {
    const cache = await caches.open('offline-fallback');
    try {
      await cache.add(FALLBACK_HTML_URL);
    } catch (error) {
      console.error('Failed to cache offline fallback page', error);
    }
  };
  event.waitUntil(cacheOfflineFallbackPage());
});

// Handle sync events for background syncing
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-orders') {
    event.waitUntil(syncOrders());
  } else if (event.tag === 'sync-items') {
    event.waitUntil(syncItems());
  }
});

// Function to sync orders when back online
async function syncOrders() {
  try {
    // Get all pending order updates from IndexedDB
    const db = await idb.openDB('workshop-db', 1);
    const pendingOrders = await db.getAll('pendingOrders');
    
    if (pendingOrders.length > 0) {
      // Process each pending order update
      for (const order of pendingOrders) {
        // Send update to server
        const response = await fetch(`/api/orders/${order.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(order)
        });
        
        if (response.ok) {
          // Remove from pending if successful
          await db.delete('pendingOrders', order.id);
        }
      }
    }
  } catch (error) {
    console.error('Error syncing orders:', error);
  }
}

// Function to sync items when back online
async function syncItems() {
  try {
    // Get all pending item updates from IndexedDB
    const db = await idb.openDB('workshop-db', 1);
    const pendingItems = await db.getAll('pendingItems');
    
    if (pendingItems.length > 0) {
      // Process each pending item update
      for (const item of pendingItems) {
        // Send update to server
        const response = await fetch(`/api/order-items/${item.id}`, {
          method: 'PATCH',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(item)
        });
        
        if (response.ok) {
          // Remove from pending if successful
          await db.delete('pendingItems', item.id);
        }
      }
    }
  } catch (error) {
    console.error('Error syncing items:', error);
  }
}